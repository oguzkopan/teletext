# Kiro Usage Guide

This document explains how Modern Teletext was built using [Kiro](https://kiro.ai), an AI-powered development assistant, and how you can use Kiro features for your own development.

## Table of Contents

- [What is Kiro?](#what-is-kiro)
- [Specs (Specification-Driven Development)](#specs-specification-driven-development)
- [Hooks](#hooks)
- [Steering](#steering)
- [MCP (Model Context Protocol)](#mcp-model-context-protocol)
- [Best Practices](#best-practices)
- [Examples from This Project](#examples-from-this-project)

## What is Kiro?

Kiro is an AI-powered development assistant that helps you build software through:
- **Structured specifications** (requirements, design, tasks)
- **Automated workflows** (hooks)
- **Context-aware assistance** (steering)
- **External tool integration** (MCP)

### Key Benefits

- **Correctness**: Property-based testing ensures code meets specifications
- **Structure**: Systematic approach from requirements to implementation
- **Documentation**: Auto-generated from specifications
- **Efficiency**: Task-by-task implementation with clear objectives
- **Quality**: Built-in testing strategy from design phase

## Specs (Specification-Driven Development)

Specs are the foundation of Kiro's development methodology. A spec consists of three documents that guide the entire development process.

### The Three Documents

#### 1. Requirements (`requirements.md`)

**Purpose**: Define what the system should do

**Format**: EARS (Easy Approach to Requirements Syntax) with INCOSE quality rules

**Structure**:
```markdown
# Requirements Document

## Introduction
[System overview]

## Glossary
- **Term**: Definition

## Requirements

### Requirement 1
**User Story:** As a [role], I want [feature], so that [benefit]

#### Acceptance Criteria
1. WHEN [event], THE [System] SHALL [response]
2. WHILE [state], THE [System] SHALL [response]
3. IF [condition], THEN THE [System] SHALL [response]
```

**Example from Modern Teletext**:
```markdown
### Requirement 1
**User Story:** As a user, I want to navigate between pages using 
three-digit page numbers, so that I can access information with the 
authentic teletext experience.

#### Acceptance Criteria
1. WHEN a user enters a three-digit page number (100-899) THEN the 
   Teletext System SHALL display the corresponding page within 500 
   milliseconds
2. WHEN a user enters an invalid page number THEN the Teletext System 
   SHALL display an error message and remain on the current page
```

#### 2. Design (`design.md`)

**Purpose**: Define how the system will be built

**Structure**:
```markdown
# Design Document

## Overview
[Architecture overview]

## Architecture
[System architecture with diagrams]

## Components and Interfaces
[Component specifications]

## Data Models
[Data structures]

## Correctness Properties
[Property-based testing properties]

## Error Handling
[Error handling strategy]

## Testing Strategy
[Unit and property-based testing approach]
```

**Key Section: Correctness Properties**

Each property is a universal statement that must hold for all valid inputs:

```markdown
### Property 1: Page dimension invariant
*For any* teletext page generated by the system, the page must contain 
exactly 24 rows and each row must be at most 40 characters in length.
**Validates: Requirements 2.1, 2.2, 11.5**
```

These properties become property-based tests in the implementation phase.

#### 3. Tasks (`tasks.md`)

**Purpose**: Break down implementation into actionable steps

**Structure**:
```markdown
# Implementation Plan

- [ ] 1. Set up project structure
  - Create directory structure
  - Set up testing framework
  - _Requirements: 1.1_

- [ ] 2. Implement core functionality
- [ ] 2.1 Create data models
  - Write TypeScript interfaces
  - _Requirements: 2.1, 3.3_

- [ ]* 2.2 Write property test for data models
  - **Property 1: Page dimension invariant**
  - **Validates: Requirements 2.1**

- [ ] 3. Checkpoint - Ensure all tests pass
```

**Key Features**:
- Hierarchical task structure (max 2 levels)
- Optional tasks marked with `*` (typically tests)
- Each task references specific requirements
- Property tests explicitly reference design properties
- Checkpoints for validation

### Using Specs in Kiro

#### Creating a New Spec

1. **Start with an idea**: Describe what you want to build
2. **Kiro generates requirements**: Based on your description
3. **Review and refine**: Iterate until requirements are complete
4. **Kiro generates design**: Including correctness properties
5. **Review and refine**: Iterate until design is solid
6. **Kiro generates tasks**: Actionable implementation steps
7. **Execute tasks**: One at a time with Kiro's assistance

#### Executing Tasks

```bash
# Open the tasks file in Kiro
open .kiro/specs/modern-teletext/tasks.md

# Click "Start task" next to any task
# Kiro will:
# 1. Read requirements and design
# 2. Implement the task
# 3. Write tests (if applicable)
# 4. Verify implementation
# 5. Mark task as complete
```

#### Updating Specs

```bash
# To add a new feature:
# 1. Add requirement to requirements.md
# 2. Ask Kiro to update design and tasks

# To modify existing feature:
# 1. Update requirement
# 2. Ask Kiro to regenerate affected design/tasks
```

### Spec Workflow

```
Idea → Requirements → Design → Tasks → Implementation
  ↓         ↓           ↓        ↓           ↓
Review    Review      Review   Review      Review
  ↓         ↓           ↓        ↓           ↓
Refine    Refine      Refine   Execute     Verify
```

## Hooks

Hooks automate workflows by triggering actions when events occur.

### What are Hooks?

Hooks allow Kiro to automatically execute tasks when:
- A message is sent to the agent
- An agent execution completes
- A new session is created
- A file is saved
- A user clicks a button

### Hook Types

#### 1. On Save Hooks

**Example**: Run tests when saving adapter files

```yaml
name: Test Adapter on Save
trigger: file_save
pattern: "functions/src/adapters/*.ts"
action: run_tests
command: "cd functions && npm test -- ${file}"
```

#### 2. On Commit Hooks

**Example**: Validate tests before commit

```yaml
name: Pre-commit Validation
trigger: pre_commit
action: run_command
command: "npm test && npm run lint"
```

#### 3. Manual Hooks

**Example**: Spell-check documentation

```yaml
name: Spell Check Docs
trigger: manual
action: send_message
message: "Review and fix grammar errors in README.md"
```

### Creating Hooks in Kiro

1. **Open Kiro Hook UI**: Command Palette → "Open Kiro Hook UI"
2. **Define trigger**: Choose event type
3. **Define action**: Command or message
4. **Test hook**: Trigger event and verify
5. **Save hook**: Hook is now active

### Useful Hooks for Modern Teletext

```yaml
# Run tests on adapter changes
name: Test Adapters
trigger: file_save
pattern: "functions/src/adapters/*.ts"
action: run_command
command: "cd functions && npm test -- ${file}"

# Update documentation on spec changes
name: Update Docs
trigger: file_save
pattern: ".kiro/specs/**/*.md"
action: send_message
message: "Spec updated. Review and update related documentation."

# Validate before deployment
name: Pre-deploy Check
trigger: manual
action: run_command
command: "npm test && npm run build && npm run lint"
```

## Steering

Steering files provide context and instructions to Kiro for specific scenarios.

### What is Steering?

Steering files are markdown documents in `.kiro/steering/` that:
- Provide project-specific context
- Define coding standards
- Explain architectural decisions
- Guide Kiro's behavior

### Types of Steering

#### 1. Always Included

**File**: `.kiro/steering/project-conventions.md`

**Purpose**: Always available context

**Example**:
```markdown
# Project Conventions

## 40×24 Grid Constraint
All teletext pages must render exactly 24 rows of 40 characters.

## Page Number Validation
Valid page numbers: 100-899

## Error Handling
Always return teletext-formatted error pages, never throw exceptions.

## Testing
- Write property-based tests for universal properties
- Write unit tests for specific examples
- Maintain 85%+ coverage
```

#### 2. Conditional (File Match)

**File**: `.kiro/steering/adapter-guidelines.md`

**Front Matter**:
```yaml
---
inclusion: fileMatch
fileMatchPattern: 'functions/src/adapters/*.ts'
---
```

**Purpose**: Included when editing adapter files

**Example**:
```markdown
# Adapter Guidelines

## Adapter Interface
All adapters must implement:
- getPage(pageId: string): Promise<TeletextPage>
- getCacheKey(pageId: string): string
- getCacheDuration(): number

## Error Handling
Return error pages, don't throw exceptions.

## Caching
Set appropriate TTL based on content type.
```

#### 3. Manual

**File**: `.kiro/steering/deployment-procedures.md`

**Front Matter**:
```yaml
---
inclusion: manual
---
```

**Purpose**: User explicitly includes with `#deployment-procedures`

**Example**:
```markdown
# Deployment Procedures

## Pre-deployment Checklist
1. Run all tests
2. Update version number
3. Update CHANGELOG
4. Build production bundle
5. Deploy to staging
6. Smoke test staging
7. Deploy to production
```

### Creating Steering Files

1. **Create file**: `.kiro/steering/my-steering.md`
2. **Add front matter** (if conditional/manual):
   ```yaml
   ---
   inclusion: fileMatch
   fileMatchPattern: 'pattern/*.ts'
   ---
   ```
3. **Write content**: Guidelines, context, examples
4. **Test**: Verify Kiro uses the steering

### Steering Best Practices

- **Be Specific**: Provide concrete examples
- **Be Concise**: Focus on essential information
- **Be Consistent**: Use consistent terminology
- **Update Regularly**: Keep steering current with code
- **Use File References**: Include related files with `#[[file:path]]`

## MCP (Model Context Protocol)

MCP allows Kiro to integrate with external tools and services.

### What is MCP?

MCP is a protocol for connecting Kiro to:
- External APIs
- Development tools
- Cloud services
- Custom integrations

### Configuration

**File**: `.kiro/settings/mcp.json`

```json
{
  "mcpServers": {
    "firebase": {
      "command": "uvx",
      "args": ["firebase-mcp-server@latest"],
      "env": {
        "FIREBASE_PROJECT_ID": "your-project-id"
      },
      "disabled": false,
      "autoApprove": ["listProjects", "getConfig"]
    }
  }
}
```

### Available MCP Servers

#### Firebase MCP

**Purpose**: Direct Firebase console access

**Capabilities**:
- List projects
- Get configuration
- View Firestore data
- Check function logs

**Setup**:
```json
{
  "mcpServers": {
    "firebase": {
      "command": "uvx",
      "args": ["firebase-mcp-server@latest"],
      "env": {
        "FIREBASE_PROJECT_ID": "teletext-eacd0"
      }
    }
  }
}
```

#### API Testing MCP

**Purpose**: Test external API integrations

**Capabilities**:
- Make HTTP requests
- Validate responses
- Test error handling

#### Documentation MCP

**Purpose**: Generate API docs from code

**Capabilities**:
- Extract JSDoc comments
- Generate markdown docs
- Create API reference

### Using MCP in Kiro

1. **Configure MCP server**: Edit `.kiro/settings/mcp.json`
2. **Restart Kiro**: Reconnect MCP servers
3. **Use MCP tools**: Kiro can now access external tools
4. **Auto-approve**: List trusted tools in `autoApprove`

### MCP Best Practices

- **Security**: Only enable trusted MCP servers
- **Auto-approve**: Carefully select auto-approved tools
- **Environment Variables**: Use env vars for sensitive data
- **Testing**: Test MCP integrations before relying on them

## Best Practices

### Spec-Driven Development

1. **Start with Requirements**: Don't skip to implementation
2. **Iterate on Design**: Refine until solid
3. **One Task at a Time**: Don't rush through tasks
4. **Review Checkpoints**: Validate at checkpoints
5. **Update Specs**: Keep specs current with code

### Property-Based Testing

1. **Write Properties First**: Before implementation
2. **Test Universal Rules**: Not specific examples
3. **Use Smart Generators**: Constrain input space intelligently
4. **Handle Failures**: Triage counterexamples carefully
5. **Iterate on Properties**: Refine as you learn

### Working with Kiro

1. **Be Specific**: Clear instructions get better results
2. **Provide Context**: Use steering for project-specific info
3. **Review Output**: Always review Kiro's code
4. **Iterate**: Refine until correct
5. **Learn Patterns**: Understand what works well

### Documentation

1. **Document as You Go**: Don't defer documentation
2. **Use Specs**: Specs are living documentation
3. **Keep Updated**: Update docs with code changes
4. **Examples**: Include code examples
5. **Searchable**: Use descriptive titles and headings

## Examples from This Project

### Spec Structure

```
.kiro/specs/modern-teletext/
├── requirements.md    # 30 user stories, 150+ acceptance criteria
├── design.md          # Architecture, 30 correctness properties
└── tasks.md           # 30 tasks, 100+ sub-tasks
```

### Property-Based Test Example

**Property from Design**:
```markdown
### Property 1: Page dimension invariant
*For any* teletext page generated by the system, the page must contain 
exactly 24 rows and each row must be at most 40 characters in length.
**Validates: Requirements 2.1, 2.2, 11.5**
```

**Implementation**:
```typescript
import fc from 'fast-check';

it('Property 1: Page dimension invariant', () => {
  // Feature: modern-teletext, Property 1: Page dimension invariant
  fc.assert(
    fc.property(
      fc.record({
        id: fc.integer({ min: 100, max: 899 }).map(n => n.toString()),
        title: fc.string(),
        content: fc.array(fc.string())
      }),
      async (pageData) => {
        const adapter = new MockAdapter(pageData);
        const page = await adapter.getPage(pageData.id);
        
        expect(page.rows).toHaveLength(24);
        expect(page.rows.every(row => row.length <= 40)).toBe(true);
      }
    ),
    { numRuns: 100 }
  );
});
```

### Steering Example

**File**: `.kiro/steering/teletext-constraints.md`

```markdown
# Teletext Constraints

## Critical Rules

### 40×24 Grid
Every page MUST have exactly 24 rows, each ≤40 characters.

### Page Numbers
Valid range: 100-899. No exceptions.

### Color Codes
Use only: red, green, yellow, blue, magenta, cyan, white, black.

### Error Handling
Return error pages in teletext format. Never throw exceptions to user.

## Examples

### Valid Page
```typescript
{
  id: "201",
  rows: ["...", "..."], // Exactly 24 rows
  // Each row ≤40 chars
}
```

### Invalid Page
```typescript
{
  id: "201",
  rows: ["..."], // Only 1 row - INVALID
}
```
```

### Hook Example

**Adapter Test Hook**:
```yaml
name: Test Adapter on Save
trigger: file_save
pattern: "functions/src/adapters/*.ts"
action: run_command
command: |
  cd functions
  npm test -- ${file}
  if [ $? -eq 0 ]; then
    echo "✅ Tests passed"
  else
    echo "❌ Tests failed"
    exit 1
  fi
```

## Resources

- **Kiro Documentation**: https://kiro.ai/docs
- **Spec Examples**: `.kiro/specs/modern-teletext/`
- **Steering Examples**: `.kiro/steering/`
- **Property-Based Testing**: fast-check documentation

## Questions?

For questions about using Kiro:
1. Check Kiro documentation
2. Review this guide
3. Examine spec examples in this project
4. Ask in Kiro community

---

**Last Updated**: January 2024  
**Kiro Version**: Latest  
**Project**: Modern Teletext
